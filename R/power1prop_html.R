#' Power and Sample Size Calculation for One-Sample Proportion Test
#'
#' Calculates sample size (`n`), alternative proportion (`p2`), or statistical power
#' for a one-sample proportion test using the normal approximation method. The
#' function is designed to handle vectors of input parameters (n, p2, power) and
#' formats the results as an HTML table and data for a power curve plot.
#'
#' The function relies on an internal function, `one_prop_power_calculator`,
#' for the actual statistical calculation.
#'
#' @param solvefor A character string specifying the parameter to solve for.
#'   Must be one of \code{"n"} (sample size), \code{"p2"} (alternative proportion),
#'   or \code{"power"} (test power).
#' @param n Sample size(s). Required if \code{solvefor} is \code{"power"} or \code{"p2"}.
#'   Can be a single value or a vector of values.
#' @param p1 The proportion under the null hypothesis (\eqn{p_0}). Must be a single value (0 < p1 < 1).
#' @param p2 The proportion(s) under the alternative hypothesis (\eqn{p_a}).
#'   Required if \code{solvefor} is \code{"n"} or \code{"power"}. Can be a single
#'   value or a vector of values.
#' @param sig.level The significance level (Type I error rate, \eqn{\alpha}). Must be a single value.
#' @param power The statistical power (\eqn{1 - \beta}, Type II error rate).
#'   Required if \code{solvefor} is \code{"n"} or \code{"p2"}. Can be a single
#'   value or a vector of values.
#' @param alt_ttest A character string specifying the alternative hypothesis.
#'   Must be one of \code{"two.sided"} (default), \code{"greater"}, or \code{"less"}.
#' @param font_size An integer specifying the font size for the generated HTML table (used by \code{kableExtra}). Default is 18.
#' @param nd An integer specifying the number of decimal places for formatting the
#'   output values (\code{p2}, \code{TargetP}). Requires the existence of a
#'   custom function \code{ndformat}. Default is 1.
#'
#' @return A list containing two elements:
#' \item{table_out}{An HTML table object (of class \code{knitr_kable}) containing
#'   the power analysis results, styled with \code{kableExtra}.}
#' \item{data_plot}{A data frame containing the data points used to generate a
#'   power curve plot, including columns for \code{p1}, \code{Ss} (Sample Size),
#'   \code{X} (Alternative Proportion $p_a$ range), and \code{Y} (Calculated Power).}
#'
#' @details
#' When \code{solvefor="n"}, the calculated sample size is \code{ceiling} (rounded up)
#' to ensure at least the target power is reached. The function returns the
#' \code{ActualP} achieved by this rounded-up sample size.
#'
#' The power curve data (\code{data_plot}) is generated by calculating power over a range
#' of alternative proportions (\eqn{p_a}) centered around the input \code{p2} or \code{p1}.
#'
#' @seealso \code{\link[stats]{power.prop.test}}, \code{\link[knitr]{kable}}, \code{\link[kableExtra]{kable_styling}}
#'
#' @export
#'
#' @examples
#' # Assuming 'one_prop_power_calculator' and 'ndformat' are defined:
#'
#' # 1. Solve for Sample Size (n)
#' \dontrun{
#'  results_n <- power1prop_html(solvefor = "n", p1 = 0.2, p2 = c(0.3, 0.4),
#'                               sig.level = 0.05, power = 0.8,
#'                               alt_ttest = "two.sided")
#'  print(results_n$table_out)
#' }
#'
#' # 2. Solve for Power
#' \dontrun{
#'  results_power <- power1prop_html(solvefor = "power", n = c(50, 100), p1 = 0.2,
#'                                   p2 = 0.3, sig.level = 0.05,
#'                                   alt_ttest = "greater")
#'  print(results_power$table_out)
#' }
#'
#' @export



power1prop_html <- function(solvefor="n",n=NULL, p1, p2=NULL, sig.level, power=NULL, alt_ttest = "two.sided", font_size=18,nd=1) { 
  
  if (solvefor=="n") {
    #n <- NULL
    pointer <- expand.grid(p_alt = p2,power = power)
    }
  if (solvefor=="p2") {
    #delta <- NULL
    pointer <- expand.grid(n=n,power = power)
  } 
  if (solvefor=="power") {
    #power <- NULL
    pointer <- expand.grid(n=n,p_alt = p2)
  } 
  
  alternative <- dplyr::case_when(
    alt_ttest == "greater" ~ "one.sided",
    alt_ttest == "less" ~ "one.sided",
    alt_ttest == "two.sided" ~ "two.sided"
  )
  
  
  
  temp <- lapply(1:dim(pointer)[1],function(i) {
    fit <- one_prop_power_calculator(n=pointer$n[i], p_null=p1, p_alt=pointer$p_alt[i], alpha=sig.level, power=pointer$power[i],
                                  alternative = alt_ttest)
    
    if (solvefor=="n") {
      fittp <- one_prop_power_calculator(n=ceiling(fit$n),
                                         p_null=p1, p_alt=pointer$p_alt[i], alpha=sig.level,
                                   power=NULL, alternative = alt_ttest)
      fittp <- ndformat(fittp$power,nd)
    } else fittp<- NA
    
    dframe <- data.frame(
      p1 = fit$p_null,
      p2 = fit$p_alt,
      Ss = ceiling(fit$n),
      TargetP = fit$power,
      ActualP = fittp
    )
    row.names(dframe) <- NULL
    dframe
  })
  dframe <- do.call("rbind",temp)
  dframe <- dframe %>% arrange(-Ss)
  
  dafra <- dframe
  
  if (solvefor=="p2") dafra$p2 <- ndformat(dafra$p2,nd)
  if (solvefor=="power") dafra$TargetP <- ndformat(dafra$TargetP,nd)

  #if (alt_ttest == "two.sided") dafra$p2 <- paste("&plusmn;",dafra$p2,sep="")
  #if (alt_ttest == "less") dafra$p2 <- paste("-",dafra$p2,sep="")
  
  # Define the table column headers with HTML formatting.
  col_headers_html <- c(
    "Prop null (p<sub>0</sub>)","Prop alternative (p<sub>a</sub>)", "Sample Size", "Target Power", "Actual Power")
  
  # Conditionally remove columns if !solvefor=="n"
  if (!solvefor=="n") {
    dafra <- dafra %>% dplyr::select(-ActualP)
    col_headers_html <- col_headers_html[!col_headers_html %in% "Actual Power"]
  }
  
  
  
  # Create the HTML string for the table caption.
  caption_html <- paste(
    "<p style='text-align: left; margin-left: 0; font-size: ",
    font_size + 2,
    "px; color: maroon; font-weight: bold;'>Results</p>",
    sep = ""
  )
  
  
  # Define the HTML strings for footnotes based on test type.
  #fn0 <- paste("<span style='color: purple; font-weight: bold;'>The sample size is for each group</span>")
  fn1 <- "Test for One proportion"
  fn2 <- dplyr::case_when(
    alt_ttest == "greater" ~ paste("Testing p = p<sub>0</sub> (versus p &gt; p<sub>0</sub>)", sep = ""),
    alt_ttest == "less" ~ paste("Testing p = p<sub>0</sub> (versus p &lt; p<sub>0</sub>)", sep = ""),
    alt_ttest == "two.sided" ~ paste("Testing p = p<sub>0</sub> (versus p &ne; p<sub>0</sub>)", sep = "")
  )
  #fn3 <- "&Delta; = |p<sub>2</sub>-p<sub>1</sub>|"
  #fn4 <- dplyr::case_when(
  #  alt_ttest == "greater" ~ paste("Calculating power for p<sub>2</sub> = p<sub>1</sub> + &Delta;", sep = ""),
  #  alt_ttest == "less" ~ paste("Calculating power for p<sub>2</sub> = p<sub>1</sub> - &Delta;", sep = ""),
  #  alt_ttest == "two.sided" ~ paste("Calculating power for p<sub>2</sub> = p<sub>1</sub> &plusmn; &Delta;", sep = "")
  #)
  fn3 <- "Calculating power for p<sub>a</sub>"
  fn4 <- paste("&alpha; = ",sig.level,sep="")
  
  #fn0 <- paste("<i>", fn0, "<i>", sep = "")
  fn1 <- paste("<i>", fn1, "<i>", sep = "")
  fn2 <- paste("<i>", fn2, "<i>", sep = "")
  fn3 <- paste("<i>", fn3, "<i>", sep = "")
  fn4 <- paste("<i>", fn4, "<i>", sep = "")
  #fn5 <- paste("<i>", fn5, "<i>", sep = "")
  footnotes_html <- c(fn1, fn2, fn3, fn4)
  
  
  ####################################
  ### Choose what column to highlight
  ####################################
  if (solvefor=="n") pico <- 3
  if (solvefor=="p2") pico <- 2
  if (solvefor=="power") pico <- 4
  
  # --- 3. BUILD THE KABLEEXTRA TABLE ---
  
  table_out <- knitr::kable(
    dafra,
    format = "html",
    align = "c",
    col.names = col_headers_html,
    caption = caption_html,
    escape = FALSE
  ) %>%
    # Style the table layout and font.
    kableExtra::kable_styling(
      full_width = FALSE,
      position = "left",
      font_size = font_size
    ) %>%
    # Add vertical borders and padding to columns.
    kableExtra::column_spec(
      column = 1:dim(dafra)[2],
      border_left = "1px solid #ddd",
      border_right = "1px solid #ddd",
      extra_css = "white-space: nowrap; padding-top: 2px; padding-bottom: 2px; padding-left: 10px; padding-right: 10px;"
    ) %>%
    # Make the first column (Variable) bold.
    kableExtra::column_spec(
      column = pico,
      bold = TRUE
    ) %>%
    # Add horizontal borders to the header and bold the text.
    kableExtra::row_spec(
      row = 0,
      bold = TRUE,
      extra_css = "white-space: nowrap; border-bottom: 2px solid #666; border-top: 1px solid #ddd;; padding-left: 10px; padding-right: 10px;"
    ) %>%
    # Add horizontal borders to the first data row.
    kableExtra::row_spec(
      row = dim(dafra)[1],
      extra_css = "border-bottom: 2px solid #666;"
    ) %>%
    # Add footnotes to the table.
    kableExtra::footnote(
      general = footnotes_html,
      escape = FALSE,
      general_title = ""
    )
  
  
  #############################################################
  ### Now creeates the power curves from the entries in dframe
  #############################################################
  
  #extrax <- (max(as.numeric(dframe$p2) )*2)/10

  #if (alt_ttest == "greater") rangmin <- as.numeric(dframe$p1[i]
  
  dframe <- dframe %>% mutate(rangemin = case_when(alt_ttest == "greater"~as.numeric(dframe$p1),
                                                   alt_ttest == "less"~as.numeric(dframe$p2),
                                                   alt_ttest == "two.sided"~as.numeric(dframe$p1) - abs(as.numeric(dframe$p2)-as.numeric(dframe$p1)) ))     
  dframe <- dframe %>% mutate(rangemax = case_when(alt_ttest == "greater"~as.numeric(dframe$p2),
                                                   alt_ttest == "less"~as.numeric(dframe$p1),
                                                   alt_ttest == "two.sided"~as.numeric(dframe$p1) + abs(as.numeric(dframe$p2)-as.numeric(dframe$p1)) ))     
  dframe <- dframe %>% mutate(extra = (rangemax-rangemin)/10 )
  if (alt_ttest == "greater") dframe <- dframe %>% mutate(rangemax=rangemax+extra)
  if (alt_ttest == "less") dframe <- dframe %>% mutate(rangemin=rangemin -extra)
  if (alt_ttest == "two.sided") dframe <- dframe %>% mutate(rangemin=rangemin-extra,rangemax=rangemax+extra)

  dframe <- dframe %>% mutate(rangemax = pmin(rangemax,1))
  dframe <- dframe %>% mutate(rangemin = pmax(rangemin,0))
  
  temp <- lapply(1:dim(dframe)[1],function(i) {
    #dt <- abs(as.numeric(dframe$p2[i]) - as.numeric(dframe$p1[i]))
    #extrax <- dt*2/10
    #delta_range <- seq(max(as.numeric(dframe$p1[i])-dt-extrax,0),min(as.numeric(dframe$p1[i])+dt+extrax,1),length.out = 300) 
    delta_range <- seq(dframe$rangemin[i],dframe$rangemax[i],length.out = 300) 
    power_values <- sapply(delta_range, function(d) {
      
      one_prop_power_calculator(n=dframe$Ss[i],
                                p_null=dframe$p1[i],
                                p_alt=d,
                                alpha=sig.level,
                                power=NULL,
                                alternative = alt_ttest)$power
    })
    if (solvefor=="n") {tp <- dframe$ActualP[i]} else {tp <- dframe$TargetP[i]}
    out <- data.frame(p1 = dframe$p1[i],
                      p2 = dframe$p2[i],
                      Ss = dframe$Ss[i],
                      TargetP = dframe$TargetP[i],
                      X = delta_range,
                      Y = power_values,
                      #name = paste("Curve ",i,sep=""),
                      alt_ttest = alt_ttest,
                      alpha = sig.level,
                      ActualP = tp)
    #if (alt_ttest == "less") {
      #out$p2 <- paste("-",out$p2,sep="")
      #out$Y <- rev(out$Y)
    #}
    out
  })
  pocu <- do.call("rbind",temp)
  
  
  list(table_out=table_out,data_plot = pocu)
}